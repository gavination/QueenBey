(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict'

var addOne = require('./helpers/add-one')
var addMany = require('./helpers/add-many')

module.exports = add

/**
 * adds one or multiple objects to local database
 *
 * @param  {Object|Object[]} properties   Properties of one or
 *                                        multiple objects
 * @return {Promise}
 */
function add (objects) {
  return Array.isArray(objects)
    ? addMany.call(this, objects)
    : addOne.call(this, objects)
}

},{"./helpers/add-many":5,"./helpers/add-one":6}],2:[function(require,module,exports){
'use strict'

module.exports = clear

/**
 * destroys db
 */
function clear (state) {
  var db = this

  return db.destroy()
    .then(function () {
      state.emitter.emit('clear')
    })
}

},{}],3:[function(require,module,exports){
'use strict'

var toObject = require('./utils/to-object')
var isntDesignDoc = require('./utils/isnt-design-doc')

module.exports = findAll

/**
 * finds all existing objects in local database.
 *
 * @param  {Function} [filter]   Function returning `true` for any object
 *                               to be returned.
 * @return {Promise}
 */
function findAll (filter) {
  return this.allDocs({
    include_docs: true
  })

  .then(function (res) {
    var objects = res.rows
      .filter(isntDesignDoc)
      .map(function (row) {
        return toObject(row.doc)
      })

    return typeof filter === 'function'
      ? objects.filter(filter)
      : objects
  })
}

},{"./utils/isnt-design-doc":34,"./utils/to-object":39}],4:[function(require,module,exports){
'use strict'

var findOne = require('./helpers/find-one')
var findMany = require('./helpers/find-many')

module.exports = find

/**
 * finds existing object in local database
 *
 * @param  {String|Object} idOrObject   Id of object or object with
 *                                      `.id` property
 * @return {Promise}
 */
function find (objectsOrIds) {
  return Array.isArray(objectsOrIds)
    ? findMany.call(this, objectsOrIds)
    : findOne.call(this, objectsOrIds)
}

},{"./helpers/find-many":8,"./helpers/find-one":9}],5:[function(require,module,exports){
'use strict'

var toDoc = require('../utils/to-doc')
var addTimestamps = require('../utils/add-timestamps')

module.exports = function addMany (objects) {
  objects.forEach(addTimestamps)
  return this.bulkDocs(objects.map(toDoc))

  .then(function (responses) {
    return responses.map(function (response, i) {
      if (response instanceof Error) {
        if (response.status === 409) {
          var conflict = new Error('Object with id "' + objects[i].id + '" already exists')
          conflict.name = 'Conflict'
          conflict.status = 409
          return conflict
        } else {
          return response
        }
      }

      objects[i].id = response.id
      objects[i]._rev = response.rev
      return objects[i]
    })
  })
}

},{"../utils/add-timestamps":32,"../utils/to-doc":37}],6:[function(require,module,exports){
'use strict'

var PouchDBErrors = require('pouchdb-errors')
var Promise = require('lie')

var toDoc = require('../utils/to-doc')
var addTimestamps = require('../utils/add-timestamps')

module.exports = function addOne (object) {
  if (typeof object !== 'object') {
    return Promise.reject(PouchDBErrors.NOT_AN_OBJECT)
  }

  var method = object.id ? 'put' : 'post'

  return this[method](toDoc(addTimestamps(object)))

  .then(function (response) {
    object.id = response.id
    object._rev = response.rev
    return object
  })

  .catch(function (error) {
    if (error.status === 409) {
      var conflict = new Error('Object with id "' + object.id + '" already exists')
      conflict.name = 'Conflict'
      conflict.status = 409
      throw conflict
    } else {
      throw error
    }
  })
}

},{"../utils/add-timestamps":32,"../utils/to-doc":37,"lie":22,"pouchdb-errors":24}],7:[function(require,module,exports){
module.exports = eventify

/**
 * runs a method from the API and triggers events on each object.
 *
 * Note that we didn't implement this pased on PouchDB's .changes()
 * API on purpose, because of the timeing the events would get triggered.
 * See https://github.com/hoodiehq/pouchdb-hoodie-api/issues/54
 **/
function eventify (db, state, method, eventName) {
  return function () {
    return method.apply(db, arguments).then(function (result) {
      if (Array.isArray(result)) {
        result.forEach(triggerEvent.bind(null, state, eventName))
      } else {
        triggerEvent(state, eventName, result)
      }

      return result
    })
  }
}

function triggerEvent (state, eventName, object) {
  if (!eventName) {
    eventName = parseInt(object._rev, 10) > 1 ? 'update' : 'add'
  }

  state.emitter.emit(eventName, object)
  state.emitter.emit('change', eventName, object)
}

},{}],8:[function(require,module,exports){
'use strict'

var toId = require('../utils/to-id')
var toObject = require('../utils/to-object')

module.exports = function findMany (idsOrObjects) {
  var ids = idsOrObjects.map(toId)

  return this.allDocs({keys: ids, include_docs: true})

  .then(function (response) {
    var foundMap = response.rows.reduce(function (map, row) {
      map[row.id] = row.doc
      return map
    }, {})
    var docs = ids.map(function (id) {
      var doc = foundMap[id]
      if (doc) {
        return doc
      }

      var missing = new Error('Object with id "' + id + '" is missing')
      missing.name = 'Not found'
      missing.status = 404
      return missing
    })

    return docs.map(toObject)
  })
}

},{"../utils/to-id":38,"../utils/to-object":39}],9:[function(require,module,exports){
'use strict'

var toId = require('../utils/to-id')
var toObject = require('../utils/to-object')

module.exports = function findOne (idOrObject) {
  var id = toId(idOrObject)
  return this.get(id)

  .then(toObject)

  .catch(function (error) {
    if (error.status === 404) {
      var missing = new Error('Object with id "' + id + '" is missing')
      missing.name = 'Not found'
      missing.status = 404
      throw missing
    } else {
      throw error
    }
  })
}

},{"../utils/to-id":38,"../utils/to-object":39}],10:[function(require,module,exports){
var toId = require('../utils/to-id')
var findMany = require('./find-many')
var addMany = require('./add-many')
var eventify = require('./eventify')

module.exports = function findOrAddMany (state, passedObjects) {
  var self = this
  var foundObjects
  var passedObjectIds = passedObjects.map(toId)

  return findMany.call(this, passedObjectIds)

  .then(function (_foundObjects) {
    foundObjects = _foundObjects

    var foundObjectIds = foundObjects.map(toId)
    var notFoundObjects = passedObjects.reduce(function (notFoundObjects, passedObject) {
      if (foundObjectIds.indexOf(passedObject.id) === -1) {
        notFoundObjects.push(passedObject)
      }
      return notFoundObjects
    }, [])

    if (state) {
      return eventify(self, state, addMany)(notFoundObjects)
    }

    return addMany.call(self, notFoundObjects)
  })

  .then(function (addedObjects) {
    var objects = []

    foundObjects.concat(addedObjects).forEach(function (object) {
      var index = passedObjectIds.indexOf(object.id)
      objects[index] = object
    })

    return objects
  })
}

},{"../utils/to-id":38,"./add-many":5,"./eventify":7,"./find-many":8}],11:[function(require,module,exports){
module.exports = findOrAddOne

var PouchDBErrors = require('pouchdb-errors')
var Promise = require('lie')

var toId = require('../utils/to-id')
var findOne = require('./find-one')
var addOne = require('./add-one')
var eventify = require('./eventify')

function findOrAddOne (state, idOrObject, newObject) {
  var self = this
  var id = toId(idOrObject)

  if (!id) {
    return Promise.reject(PouchDBErrors.MISSING_ID)
  }

  if (idOrObject === id && !newObject) {
    return Promise.reject(PouchDBErrors.MISSING_ID)
  }

  return findOne.call(this, id)

  .catch(function (/* error */) {
    if (typeof newObject === 'object') {
      newObject.id = id
    } else {
      newObject = idOrObject
    }

    if (state) {
      return eventify(self, state, addOne)(newObject)
    }

    return addOne.call(self, newObject)
  })
}

},{"../utils/to-id":38,"./add-one":6,"./eventify":7,"./find-one":9,"lie":22,"pouchdb-errors":24}],12:[function(require,module,exports){
'use strict'

var extend = require('pouchdb-extend')
var PouchDBErrors = require('pouchdb-errors')

var changeObject = require('../utils/change-object')
var toDoc = require('../utils/to-doc')
var addTimestamps = require('../utils/add-timestamps')
var toId = require('../utils/to-id')

var findMany = require('./find-many')

module.exports = function updateMany (array, change) {
  var self = this
  var objects
  var ids = array.map(toId)

  return findMany.call(this, array)

  .then(function (objects) {
    if (change) {
      return objects.map(function (object) {
        if (object instanceof Error) {
          return object
        }
        return changeObject(change, object)
      })
    }

    return objects.map(function (object, index) {
      var passedObject = array[index]
      if (object instanceof Error) {
        return object
      }
      if (typeof passedObject !== 'object') {
        return PouchDBErrors.NOT_AN_OBJECT
      }
      return extend(object, passedObject)
    })
  })

  .then(function (_objects) {
    objects = _objects
    var validObjects = objects.filter(function (object) {
      return !(object instanceof Error)
    })
    validObjects.forEach(addTimestamps)
    return self.bulkDocs(validObjects.map(toDoc))
  })

  .then(function (responses) {
    responses.forEach(function (response) {
      var index = ids.indexOf(response.id)
      objects[index]._rev = response.rev
    })

    return objects
  })
}

},{"../utils/add-timestamps":32,"../utils/change-object":33,"../utils/to-doc":37,"../utils/to-id":38,"./find-many":8,"pouchdb-errors":24,"pouchdb-extend":26}],13:[function(require,module,exports){
'use strict'

var extend = require('pouchdb-extend')
var PouchDBErrors = require('pouchdb-errors')
var Promise = require('lie')

var changeObject = require('../utils/change-object')
var toDoc = require('../utils/to-doc')
var addTimestamps = require('../utils/add-timestamps')

var findOne = require('./find-one')

module.exports = function updateOne (idOrObject, change) {
  var self = this
  var object

  if (typeof idOrObject === 'string' && !change) {
    return Promise.reject(PouchDBErrors.NOT_AN_OBJECT)
  }

  return findOne.call(this, idOrObject)

  .then(function (object) {
    if (!change) {
      return extend(object, idOrObject)
    }
    return changeObject(change, object)
  })

  .then(function (_object) {
    object = _object
    return self.put(toDoc(addTimestamps(object)))
  })

  .then(function (response) {
    object._rev = response.rev
    return object
  })
}

},{"../utils/add-timestamps":32,"../utils/change-object":33,"../utils/to-doc":37,"./find-one":9,"lie":22,"pouchdb-errors":24,"pouchdb-extend":26}],14:[function(require,module,exports){
var toId = require('../utils/to-id')
var addMany = require('./add-many')
var updateMany = require('./update-many')

module.exports = function updateOrAddMany (passedObjects) {
  var self = this
  var addedObjects
  var passedObjectIds = passedObjects.map(toId)

  return addMany.call(this, passedObjects)

  .then(function (_addedObjectsAndErrors) {
    addedObjects = _addedObjectsAndErrors
    var conflicting = passedObjects.reduce(function (array, passedObject, i) {
      var objectOrError = _addedObjectsAndErrors[i]
      var isConflictError = objectOrError instanceof Error && objectOrError.status === 409

      if (isConflictError) {
        array.push(passedObject)
      }
      return array
    }, [])

    return updateMany.call(self, conflicting)
  })

  .then(function (updatedObjects) {
    var objects = []

    updatedObjects.concat(addedObjects).forEach(function (object) {
      var index = passedObjectIds.indexOf(object.id)
      if (index !== -1) {
        objects[index] = object
      }
    })

    return objects
  })
}

},{"../utils/to-id":38,"./add-many":5,"./update-many":12}],15:[function(require,module,exports){
var toId = require('../utils/to-id')
var addOne = require('./add-one')
var updateOne = require('./update-one')

module.exports = function updateOrAddOne (idOrObject, newObject) {
  var self = this
  return updateOne.call(this, idOrObject, newObject)

  .catch(function (error) {
    if (error.status !== 404) {
      throw error
    }

    if (newObject) {
      newObject.id = toId(idOrObject)
      return addOne.call(self, newObject)
    }

    return addOne.call(self, idOrObject)
  })
}

},{"../utils/to-id":38,"./add-one":6,"./update-one":13}],16:[function(require,module,exports){
'use strict'

var exports = module.exports = { hoodieApi: hoodieApi }

var EventEmitter = require('events').EventEmitter

var eventify = require('./helpers/eventify')

function hoodieApi (options) {
  var state = {
    emitter: options && options.emitter || new EventEmitter()
  }

  return {
    db: this,
    add: eventify(this, state, require('./add')),
    find: require('./find').bind(this),
    findAll: require('./find-all').bind(this),
    findOrAdd: require('./lib/find-or-add-with-events').bind(this, state),
    update: eventify(this, state, require('./update')),
    updateOrAdd: eventify(this, state, require('./update-or-add')),
    updateAll: eventify(this, state, require('./update-all')),
    remove: eventify(this, state, require('./remove'), 'remove'),
    removeAll: eventify(this, state, require('./remove-all'), 'remove'),
    on: require('./lib/on').bind(this, state),
    one: require('./lib/one').bind(this, state),
    off: require('./lib/off').bind(this, state),
    clear: require('./clear').bind(this, state)
  }
}

/* istanbul ignore next */
if (typeof window !== 'undefined' && window.PouchDB) {
  window.PouchDB.plugin(exports)
}

},{"./add":1,"./clear":2,"./find":4,"./find-all":3,"./helpers/eventify":7,"./lib/find-or-add-with-events":17,"./lib/off":18,"./lib/on":19,"./lib/one":20,"./remove":28,"./remove-all":27,"./update":31,"./update-all":29,"./update-or-add":30,"events":21}],17:[function(require,module,exports){
'use strict'

var findOrAddOne = require('../helpers/find-or-add-one')
var findOrAddMany = require('../helpers/find-or-add-many')

module.exports = findOrAdd

/**
 * tries to find object in local database, otherwise creates new one
 * with passed properties. Triggers `add` even if new object created
 *
 * @param  {String|Object} idOrObject   id or object with `.id` property
 * @param  {Object}        [properties] Optional properties if id passed as first option
 * @return {Promise}
 */
function findOrAdd (state, idOrObjectOrArray, newObject) {
  return Array.isArray(idOrObjectOrArray)
    ? findOrAddMany.call(this, state, idOrObjectOrArray)
    : findOrAddOne.call(this, state, idOrObjectOrArray, newObject)
}

},{"../helpers/find-or-add-many":10,"../helpers/find-or-add-one":11}],18:[function(require,module,exports){
'use strict'

module.exports = off

/**
 * removes a listener for the specified event
 *
 * It will unsubscribe at most, one instance of a listener for a particular event.
 * If any single listener has subcribed multiple times to the same event,
 * then `off` must be called multiple times.
 *
 * Supported events:
 *
 * - `add`
 * - `update`
 * - `remove`
 * - `change`
 *
 * @param  {String} eventName   Name of event, one of listed above
 * @param  {Function} handler   callback for event
 */
function off (state, eventName, handler) {
  state.emitter.removeListener(eventName, handler)

  return this
}

},{}],19:[function(require,module,exports){
'use strict'

module.exports = on

/**
 * add a listener to an event
 *
 * Supported events:
 *
 * - `add`    → (object, options)
 * - `update` → (object, options)
 * - `remove` → (object, options)
 * - `change` → (eventName, object, options)
 *
 * @param  {String} eventName   Name of event, one of listed above
 * @param  {Function} handler   callback for event
 */
function on (state, eventName, handler) {
  state.emitter.on(eventName, handler)

  return this
}

},{}],20:[function(require,module,exports){
'use strict'

module.exports = one

/**
 * adds a one time listener to an event
 *
 * Supported events:
 *
 * - `add`    → (object, options)
 * - `update` → (object, options)
 * - `remove` → (object, options)
 * - `change` → (eventName, object, options)
 *
 * @param  {String} eventName   Name of event, one of listed above
 * @param  {Function} handler   callback for event
 */
function one (state, eventName, handler) {
  state.emitter.once(eventName, handler)

  return this
}

},{}],21:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],22:[function(require,module,exports){
'use strict';
var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && typeof obj === 'object' && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":23}],23:[function(require,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var inherits = _interopDefault(require('inherits'));

inherits(PouchError, Error);

function PouchError(opts) {
  Error.call(this, opts.reason);
  this.status = opts.status;
  this.name = opts.error;
  this.message = opts.reason;
  this.error = true;
}

PouchError.prototype.toString = function () {
  return JSON.stringify({
    status: this.status,
    name: this.name,
    message: this.message,
    reason: this.reason
  });
};

var UNAUTHORIZED = new PouchError({
  status: 401,
  error: 'unauthorized',
  reason: "Name or password is incorrect."
});

var MISSING_BULK_DOCS = new PouchError({
  status: 400,
  error: 'bad_request',
  reason: "Missing JSON list of 'docs'"
});

var MISSING_DOC = new PouchError({
  status: 404,
  error: 'not_found',
  reason: 'missing'
});

var REV_CONFLICT = new PouchError({
  status: 409,
  error: 'conflict',
  reason: 'Document update conflict'
});

var INVALID_ID = new PouchError({
  status: 400,
  error: 'bad_request',
  reason: '_id field must contain a string'
});

var MISSING_ID = new PouchError({
  status: 412,
  error: 'missing_id',
  reason: '_id is required for puts'
});

var RESERVED_ID = new PouchError({
  status: 400,
  error: 'bad_request',
  reason: 'Only reserved document ids may start with underscore.'
});

var NOT_OPEN = new PouchError({
  status: 412,
  error: 'precondition_failed',
  reason: 'Database not open'
});

var UNKNOWN_ERROR = new PouchError({
  status: 500,
  error: 'unknown_error',
  reason: 'Database encountered an unknown error'
});

var BAD_ARG = new PouchError({
  status: 500,
  error: 'badarg',
  reason: 'Some query argument is invalid'
});

var INVALID_REQUEST = new PouchError({
  status: 400,
  error: 'invalid_request',
  reason: 'Request was invalid'
});

var QUERY_PARSE_ERROR = new PouchError({
  status: 400,
  error: 'query_parse_error',
  reason: 'Some query parameter is invalid'
});

var DOC_VALIDATION = new PouchError({
  status: 500,
  error: 'doc_validation',
  reason: 'Bad special document member'
});

var BAD_REQUEST = new PouchError({
  status: 400,
  error: 'bad_request',
  reason: 'Something wrong with the request'
});

var NOT_AN_OBJECT = new PouchError({
  status: 400,
  error: 'bad_request',
  reason: 'Document must be a JSON object'
});

var DB_MISSING = new PouchError({
  status: 404,
  error: 'not_found',
  reason: 'Database not found'
});

var IDB_ERROR = new PouchError({
  status: 500,
  error: 'indexed_db_went_bad',
  reason: 'unknown'
});

var WSQ_ERROR = new PouchError({
  status: 500,
  error: 'web_sql_went_bad',
  reason: 'unknown'
});

var LDB_ERROR = new PouchError({
  status: 500,
  error: 'levelDB_went_went_bad',
  reason: 'unknown'
});

var FORBIDDEN = new PouchError({
  status: 403,
  error: 'forbidden',
  reason: 'Forbidden by design doc validate_doc_update function'
});

var INVALID_REV = new PouchError({
  status: 400,
  error: 'bad_request',
  reason: 'Invalid rev format'
});

var FILE_EXISTS = new PouchError({
  status: 412,
  error: 'file_exists',
  reason: 'The database could not be created, the file already exists.'
});

var MISSING_STUB = new PouchError({
  status: 412,
  error: 'missing_stub'
});

var INVALID_URL = new PouchError({
  status: 413,
  error: 'invalid_url',
  reason: 'Provided URL is invalid'
});

function createError(error, reason) {
  function CustomPouchError(reason) {
    // inherit error properties from our parent error manually
    // so as to allow proper JSON parsing.
    /* jshint ignore:start */
    for (var p in error) {
      if (typeof error[p] !== 'function') {
        this[p] = error[p];
      }
    }
    /* jshint ignore:end */
    if (reason !== undefined) {
      this.reason = reason;
    }
  }
  CustomPouchError.prototype = PouchError.prototype;
  return new CustomPouchError(reason);
}

function generateErrorFromResponse(err) {

  if (typeof err !== 'object') {
    var data = err;
    err = UNKNOWN_ERROR;
    err.data = data;
  }

  if ('error' in err && err.error === 'conflict') {
    err.name = 'conflict';
    err.status = 409;
  }

  if (!('name' in err)) {
    err.name = err.error || 'unknown';
  }

  if (!('status' in err)) {
    err.status = 500;
  }

  if (!('message' in err)) {
    err.message = err.message || err.reason;
  }

  return err;
}

exports.UNAUTHORIZED = UNAUTHORIZED;
exports.MISSING_BULK_DOCS = MISSING_BULK_DOCS;
exports.MISSING_DOC = MISSING_DOC;
exports.REV_CONFLICT = REV_CONFLICT;
exports.INVALID_ID = INVALID_ID;
exports.MISSING_ID = MISSING_ID;
exports.RESERVED_ID = RESERVED_ID;
exports.NOT_OPEN = NOT_OPEN;
exports.UNKNOWN_ERROR = UNKNOWN_ERROR;
exports.BAD_ARG = BAD_ARG;
exports.INVALID_REQUEST = INVALID_REQUEST;
exports.QUERY_PARSE_ERROR = QUERY_PARSE_ERROR;
exports.DOC_VALIDATION = DOC_VALIDATION;
exports.BAD_REQUEST = BAD_REQUEST;
exports.NOT_AN_OBJECT = NOT_AN_OBJECT;
exports.DB_MISSING = DB_MISSING;
exports.WSQ_ERROR = WSQ_ERROR;
exports.LDB_ERROR = LDB_ERROR;
exports.FORBIDDEN = FORBIDDEN;
exports.INVALID_REV = INVALID_REV;
exports.FILE_EXISTS = FILE_EXISTS;
exports.MISSING_STUB = MISSING_STUB;
exports.IDB_ERROR = IDB_ERROR;
exports.INVALID_URL = INVALID_URL;
exports.createError = createError;
exports.generateErrorFromResponse = generateErrorFromResponse;
},{"inherits":25}],25:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],26:[function(require,module,exports){
"use strict";

// Extends method
// (taken from http://code.jquery.com/jquery-1.9.0.js)
// Populate the class2type map
var class2type = {};

var types = [
  "Boolean", "Number", "String", "Function", "Array",
  "Date", "RegExp", "Object", "Error"
];
for (var i = 0; i < types.length; i++) {
  var typename = types[i];
  class2type["[object " + typename + "]"] = typename.toLowerCase();
}

var core_toString = class2type.toString;
var core_hasOwn = class2type.hasOwnProperty;

function type(obj) {
  if (obj === null) {
    return String(obj);
  }
  return typeof obj === "object" || typeof obj === "function" ?
    class2type[core_toString.call(obj)] || "object" :
    typeof obj;
}

function isWindow(obj) {
  return obj !== null && obj === obj.window;
}

function isPlainObject(obj) {
  // Must be an Object.
  // Because of IE, we also have to check the presence of
  // the constructor property.
  // Make sure that DOM nodes and window objects don't pass through, as well
  if (!obj || type(obj) !== "object" || obj.nodeType || isWindow(obj)) {
    return false;
  }

  try {
    // Not own constructor property must be Object
    if (obj.constructor &&
      !core_hasOwn.call(obj, "constructor") &&
      !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
      return false;
    }
  } catch ( e ) {
    // IE8,9 Will throw exceptions on certain host objects #9897
    return false;
  }

  // Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  var key;
  for (key in obj) {}

  return key === undefined || core_hasOwn.call(obj, key);
}


function isFunction(obj) {
  return type(obj) === "function";
}

var isArray = Array.isArray || function (obj) {
  return type(obj) === "array";
};

function extend() {
  // originally extend() was recursive, but this ended up giving us
  // "call stack exceeded", so it's been unrolled to use a literal stack
  // (see https://github.com/pouchdb/pouchdb/issues/2543)
  var stack = [];
  var i = -1;
  var len = arguments.length;
  var args = new Array(len);
  while (++i < len) {
    args[i] = arguments[i];
  }
  var container = {};
  stack.push({args: args, result: {container: container, key: 'key'}});
  var next;
  while ((next = stack.pop())) {
    extendInner(stack, next.args, next.result);
  }
  return container.key;
}

function extendInner(stack, args, result) {
  var options, name, src, copy, copyIsArray, clone,
    target = args[0] || {},
    i = 1,
    length = args.length,
    deep = false,
    numericStringRegex = /\d+/,
    optionsIsArray;

  // Handle a deep copy situation
  if (typeof target === "boolean") {
    deep = target;
    target = args[1] || {};
    // skip the boolean and the target
    i = 2;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if (typeof target !== "object" && !isFunction(target)) {
    target = {};
  }

  // extend jQuery itself if only one argument is passed
  if (length === i) {
    /* jshint validthis: true */
    target = this;
    --i;
  }

  for (; i < length; i++) {
    // Only deal with non-null/undefined values
    if ((options = args[i]) != null) {
      optionsIsArray = isArray(options);
      // Extend the base object
      for (name in options) {
        //if (options.hasOwnProperty(name)) {
        if (!(name in Object.prototype)) {
          if (optionsIsArray && !numericStringRegex.test(name)) {
            continue;
          }

          src = target[name];
          copy = options[name];

          // Prevent never-ending loop
          if (target === copy) {
            continue;
          }

          // Recurse if we're merging plain objects or arrays
          if (deep && copy && (isPlainObject(copy) ||
              (copyIsArray = isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray(src) ? src : [];

            } else {
              clone = src && isPlainObject(src) ? src : {};
            }

            // Never move original objects, clone them
            stack.push({
              args: [deep, clone, copy],
              result: {
                container: target,
                key: name
              }
            });

          // Don't bring in undefined values
          } else if (copy !== undefined) {
            if (!(isArray(options) && isFunction(copy))) {
              target[name] = copy;
            }
          }
        }
      }
    }
  }

  // "Return" the modified object by setting the key
  // on the given container
  result.container[result.key] = target;
}


module.exports = extend;



},{}],27:[function(require,module,exports){
'use strict'

var toObject = require('./utils/to-object')
var toDoc = require('./utils/to-doc')
var isntDesignDoc = require('./utils/isnt-design-doc')
var addTimestamps = require('./utils/add-timestamps')

module.exports = removeAll

/**
 * removes all existing objects
 *
 * @param  {Function} [filter]   Function returning `true` for any object
 *                               to be removed.
 * @return {Promise}
 */
function removeAll (filter) {
  var objects

  return this.allDocs({
    include_docs: true
  })

  .then(function (res) {
    objects = res.rows
      .filter(isntDesignDoc)
      .map(function (row) {
        return toObject(row.doc)
      })

    if (typeof filter === 'function') {
      objects = objects.filter(filter)
    }

    return objects.map(function (object) {
      object._deleted = true
      return toDoc(addTimestamps(object))
    })
  })

  .then(this.bulkDocs.bind(this))

  .then(function (results) {
    return results.map(function (result, i) {
      objects[i]._rev = result.rev
      return objects[i]
    })
  })
}

},{"./utils/add-timestamps":32,"./utils/isnt-design-doc":34,"./utils/to-doc":37,"./utils/to-object":39}],28:[function(require,module,exports){
'use strict'

var markAsDeleted = require('./utils/mark-as-deleted')

var updateOne = require('./helpers/update-one')
var updateMany = require('./helpers/update-many')

module.exports = remove

/**
 * removes existing object
 *
 * @param  {Object|Function} objectsOrIds   id or object with `.id` property
 * @param  {Object|Function} [change]       Change properties or function that
 *                                          changes existing object
 * @return {Promise}
 */
function remove (objectsOrIds, change) {
  return Array.isArray(objectsOrIds)
    ? updateMany.call(this, objectsOrIds.map(markAsDeleted.bind(null, change)))
    : updateOne.call(this, markAsDeleted(change, objectsOrIds))
}

},{"./helpers/update-many":12,"./helpers/update-one":13,"./utils/mark-as-deleted":35}],29:[function(require,module,exports){
module.exports = updateAll

var extend = require('pouchdb-extend')
var Promise = require('lie')

var toObject = require('./utils/to-object')
var toDoc = require('./utils/to-doc')
var addTimestamps = require('./utils/add-timestamps')
var isntDesignDoc = require('./utils/isnt-design-doc')

/**
 * updates all existing objects
 *
 * @param  {Object|Function} change   changed properties or function that
 *                                    alters passed object
 * @return {Promise}
 */
function updateAll (changedProperties) {
  var type = typeof changedProperties
  var objects

  if (type !== 'object' && type !== 'function') {
    return Promise.reject(new Error('Must provide object or function'))
  }

  return this.allDocs({
    include_docs: true
  })

  .then(function (res) {
    objects = res.rows
      .filter(isntDesignDoc)
      .map(function (row) {
        return toObject(row.doc)
      })

    objects.forEach(addTimestamps)

    if (type === 'function') {
      objects.forEach(changedProperties)
      return objects.map(toDoc)
    }

    return objects.map(function (object) {
      extend(object, changedProperties)
      return toDoc(object)
    })
  })

  .then(function (result) {
    return result
  })
  .then(this.bulkDocs.bind(this))

  .then(function (results) {
    return results.map(function (result, i) {
      objects[i]._rev = result.rev
      return objects[i]
    })
  })
}

},{"./utils/add-timestamps":32,"./utils/isnt-design-doc":34,"./utils/to-doc":37,"./utils/to-object":39,"lie":22,"pouchdb-extend":26}],30:[function(require,module,exports){
'use strict'

var updateOrAddOne = require('./helpers/update-or-add-one')
var updateOrAddMany = require('./helpers/update-or-add-many')

module.exports = updateOrAdd

/**
 * updates existing object, or creates otherwise.
 *
 * @param  {String|Object|Object[]} - id or object with `.id` property, or
 *                                    array of properties
 * @param  {Object} [properties]      If id passed, properties for new
 *                                    or existing object
 * @return {Promise}
 */
function updateOrAdd (idOrObjectOrArray, newObject) {
  return Array.isArray(idOrObjectOrArray)
    ? updateOrAddMany.call(this, idOrObjectOrArray)
    : updateOrAddOne.call(this, idOrObjectOrArray, newObject)
}

},{"./helpers/update-or-add-many":14,"./helpers/update-or-add-one":15}],31:[function(require,module,exports){
module.exports = update

var Promise = require('lie')

var updateOne = require('./helpers/update-one')
var updateMany = require('./helpers/update-many')

/**
 * updates existing object.
 *
 * @param  {String|Object}   idOrObject   id or object with `.id` property
 * @param  {Object|Function} [change]     Changed properties or function
 *                                        that changes existing object
 * @return {Promise}
 */
function update (objectsOrIds, change) {
  if (typeof objectsOrIds !== 'object' && !change) {
    return Promise.reject(
      new Error('Must provide change')
    )
  }

  return Array.isArray(objectsOrIds)
    ? updateMany.call(this, objectsOrIds, change)
    : updateOne.call(this, objectsOrIds, change)
}

},{"./helpers/update-many":12,"./helpers/update-one":13,"lie":22}],32:[function(require,module,exports){
'use strict'

var now = require('./now')

module.exports = function addTimestamps (object) {
  object.updatedAt = now()
  object.createdAt = object.createdAt || object.updatedAt

  if (object._deleted) {
    object.deletedAt = object.deletedAt || object.updatedAt
  }

  return object
}

},{"./now":36}],33:[function(require,module,exports){
'use strict'

var extend = require('pouchdb-extend')

/**
  * change object either by passing changed properties
  * as an object, or by passing a change function that
  * manipulates the passed object directly
  **/
module.exports = function changeObject (change, object) {
  if (typeof change === 'object') {
    return extend(object, change)
  }

  change(object)
  return object
}

},{"pouchdb-extend":26}],34:[function(require,module,exports){
'use strict'

// Checks for a design doc, so we can filters out docs that shouldn't return in *All methods
module.exports = function isntDesignDoc (row) {
  return row.id.match(/^_design/) === null
}

},{}],35:[function(require,module,exports){
'use strict'

var extend = require('pouchdb-extend')
var changeObject = require('./change-object')

// Normalizes objectOrId, applies changes if any, and mark as deleted
module.exports = function markAsDeleted (change, objectOrId) {
  var object = typeof objectOrId === 'string' ? { id: objectOrId } : objectOrId

  if (change) {
    changeObject(change, object)
  }

  return extend({_deleted: true}, object)
}

},{"./change-object":33,"pouchdb-extend":26}],36:[function(require,module,exports){
module.exports = function now () {
  return new Date().toISOString()
}

},{}],37:[function(require,module,exports){
'use strict'

var extend = require('pouchdb-extend')

module.exports = function objectToDoc (object) {
  var doc = extend({}, object, {
    _id: object.id
  })

  delete doc.id
  return doc
}

},{"pouchdb-extend":26}],38:[function(require,module,exports){
'use strict'

module.exports = function objectOrIdToId (objectOrId) {
  return typeof objectOrId === 'object' ? objectOrId.id : objectOrId
}

},{}],39:[function(require,module,exports){
'use strict'

var extend = require('pouchdb-extend')

module.exports = function docToObject (doc) {
  if (doc instanceof Error) {
    return doc
  }

  var object = extend({}, doc, {
    id: doc._id
  })

  delete object._id
  return object
}

},{"pouchdb-extend":26}]},{},[16]);
